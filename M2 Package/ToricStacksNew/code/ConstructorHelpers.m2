-----------------------------------------------------------------------------
---- Checks whether the input is a list of integers
-----------------------------------------------------------------------------
isListOfIntegers = L -> (
    instance(L, List) and all(L, x -> instance(x, ZZ))
);


-----------------------------------------------------------------------------
---- Returns the primitive ray generator for the ray generated by the given
---- list or given vector. Output type matches input type.
-----------------------------------------------------------------------------
primitiveRay = method()
primitiveRay(List) := (v) -> (
    if isListOfIntegers(v) == false then error "Expected a list of integers";
    g := abs gcd(v);
    if g == 0 then v
    else apply(v, x -> x//g)
    )

primitiveRay(Vector) := (v) -> (
    vector (primitiveRay (flatten entries v))
    )


-----------------------------------------------------------------------------
---- Place a fan given in-terms of a list of rays and a list of cones
---- into a psuedo-canonical form by sorting, making unique, and primitive,
---- all of the rays and making the cones unique and sorting them.
---- The light version only does the cone things.
-----------------------------------------------------------------------------
canonicalizeFan = method(Options => {CanonicalizeLight => false});
canonicalizeFan(List, List) := opts -> (rayList, coneList) -> (
    -- Light == true then only sorts the cones and coneList
    if opts.CanonicalizeLight == true then (
        newConeList := sort unique apply(coneList, cone -> sort unique cone);
        return (rayList, newConeList);
    );
    --
    n := #rayList;
    prmRayList := apply(rayList, v -> primitiveRay(v));
    newRayList := sort unique prmRayList;
    --
    H := new HashTable from apply(#newRayList, j -> (newRayList#j, j));
    oldIndexToNewIndex := apply(prmRayList, v -> H#v);
    --
    newConeList := sort unique apply(coneList, c->(
	    sort unique apply(c, i-> oldIndexToNewIndex#i)
	    ));
    (newRayList, newConeList)
)


-----------------------------------------------------------------------------
---- Validates whether a pair of rayList and coneList determining a fan
---- passes basic checks to make sure things down the line do not break.
---- The following things are checked:
----
---- rayList is a non-empty list of integer lists all of the same lenght
---- coneList is a non-empty list ofinteger lists whose entries are in
---- are in the correct range.
----
---- This does not guarentee there are no errors, just a reality check.
-----------------------------------------------------------------------------
validateFanData = (rayList, coneList) -> (
    -- Checking Rays
    if not instance(rayList, List) or #rayList == 0 then error "The rayList must be a non-empty list";
    d := #(rayList#0);
    if d == 0 then error "Rays cannot be empty";
    if any(rayList, v -> not isListOfIntegers(v) or #v != d) then error "All rays must be lists of integers of the same length";
    --
    -- Checking Cones
    if not instance(coneList, List) or #coneList == 0 then error "The coneList must be a non-empty list";
    if any(coneList, C -> (not instance(C, List) or #C == 0)) then error "All cones in coneList must be non-empty lists";
    n := #rayList;
    if any(coneList, C -> any(C, i -> (not instance(i, ZZ)) or i < 0 or i >= n)) then error "Each cone in coneList must be a list of valid ray indices";    --
    true
    )


-----------------------------------------------------------------------------
---- This function is a basic wrapper that allows for the input of a fan
---- in many different forms (rayList, coneList), NormalToricVariety, Fan
---- and gives a somewhat standardized output for the fan of (rayList, coneList)
----
---- There is the option to canonicalize.
-----------------------------------------------------------------------------
fanData = method(Options => {CanonicalizeFan => true, CanonicalizeLight => false})
fanData(List, List) := opts -> (rayList, coneList) -> (
    validateFanData(rayList, coneList);
    if opts.CanonicalizeFan == false then return (rayList, coneList);
    canonicalizeFan(rayList, coneList, CanonicalizeLight => opts.CanonicalizeLight) 
    )

fanData(NormalToricVariety) := opts -> (X) -> (
    fanData(rays X, max X, opts)
    )

fanData(Fan) := opts -> (F) -> (
     fanData(entries transpose rays F, maxCones F, opts)
    )


-----------------------------------------------------------------------------
--- Takes the i-th row of B and reduces it modulo the diagonal entry D_{i,i}
--- assuming that D_{i,i} !=0.
-----------------------------------------------------------------------------

reduceByDiagonal = (B, D) -> (
    diagEntries := apply(min(numRows D, numColumns D), i -> D_(i,i));
    matrix apply(numRows B, i ->(
	    apply(numColumns B, j ->(
		    if i < #diagEntries and diagEntries#i != 0 then B_(i,j) % (diagEntries#i)
		    else B_(i,j)
		    ))
	    ))
    )

-----------------------------------------------------------------------------
--- Takes a pair of matrices (B,Q) representing a stacky fan morphism,
--- beta: N ---> L then we have
--- Q = presentation of L so Q:Z^s--->Z^t such that coker(Q) = L
--- B = lift of beta i.e. B:N ---> Z^t,
--- and returns a pair (B', D) representing the same morphism beta
--- where (B',D) are in a psudeo-stadard form. Does this by  replacing the
--- presentation matrix Q by its Smith normal form D and adjusts the
--- lift B accordingly (via row operations and reduction modulo D)
-----------------------------------------------------------------------------
canonicalizeMapData = method(Options => {CanonicalizeMap => true})
canonicalizeMapData(Matrix, Matrix) := opts -> (B, Q) -> (
    if opts.CanonicalizeMap == false then return (B, Q);
    (D,P,Q') := smithNormalForm(Q);
    B' := reduceByDiagonal(P*B,D);
    (B',D)
    )


-----------------------------------------------------------------------------
---- Validates whether a pair of matrices B and Q that are part of a stacky
---- passes basic checks to make sure things down the line do not break.
---- The following things are checked:
----
---- B and Q are integer matrices
---- B and Q have the same target
----
---- This does not guarentee there are no errors, just a reality check.
-----------------------------------------------------------------------------
validateMapData = (B, Q) -> (
    if not instance(B, Matrix) or not instance(Q, Matrix) then error "B and Q must be matrices";
    if not (ring B === ZZ) or not (ring Q === ZZ) then error "B and Q must be defined over the integers";
    if numRows Q != numRows B then error "Target of B and target of Q must be the same";
    true
);



-----------------------------------------------------------------------------
---- This function is a basic wrapper that allows for the input of a map
---- beta: N ---> L where N and L are finitely generated free abelian groups
---- and N is frree in different ways:
---- i) (B,Q) where coker(Q) = L and B is a map from N to target(Q);
---- ii) (B) when L is assumed to be free
---- iii) 
---- And creates a somewhat standard output in (B,Q) form after putting
---- Q and B is somewhatcanonical form by replace Q with its SNF and chaning
---- B approriately.
-----------------------------------------------------------------------------
mapData = method(Options => {CanonicalizeMap => true})
mapData(Matrix, Matrix) := opts -> (B, Q) -> (
    validateMapData(B,Q);
    canonicalizeMapData(B, Q, CanonicalizeMap => opts.CanonicalizeMap)
    )

mapData(Matrix) := opts -> (B) -> (
    if not (ring B === ZZ) then error "Expected a ZZ-linear map or matrix";
    if not isFreeModule(source B) then error "Expected the source to be a free ZZ-module";
    if isFreeModule(target B) then (
	r := numRows B;
	Q := map(ZZ^r,ZZ^0,0);
	mapData(B,Q, opts)
	)
    else (
	L := target B;
	P := coverMap L;
	Q := matrix presentation L;
	mapData(B//P,Q, opts)
	)
    )
